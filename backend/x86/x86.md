;; X86 machine description

(code "import x86")



(instr X86Add
    (pattern (_ Binop "+" 
                (_) (_) ))
    (asmstr "add %{2},%{0}")
)


(instr X86Sub
    (pattern (_ Binop "-" 
                (_) (_) ))
    (asmstr "sub %{2},%{0}")
)

(instr X86SHLI32
    (pattern (I32 Binop "<<" 
                (I32) (I32) ))
    (asmstr "shl %cl,%{0}")
)


(instr X86SHRI32
    (pattern (I32 Binop ">>" 
                (I32) (I32) ))
    (asmstr "shr %cl,%{0}")
)



(instr X86IMulI32 
    (pattern (I32 Binop "*" 
                (I32) (I32) ))
    (asmstr "mul %{3}")
)

(instr X86IDivI32 
    (pattern (I32 Binop "/" 
                (I32) (I32) ))
    (asmstr "cdq\nidiv %{3}")
    
    (extra "    
    def getPreClobberedRegisters(self):
        return [x86.getRegisterByName('edx')]
    ")
)

(instr X86IModI32 
    (pattern (I32 Binop "%" 
                (I32) (I32) ))
    (asmstr "cdq\nidiv %{3}")
    
    (extra "    
    def getPreClobberedRegisters(self):
        return [x86.getRegisterByName('edx')]
    ")
)


(instr X86NotI32 
    (pattern (I32 Unop "!" (I32) ))
    (asmstr "        
        if self.read[0] == self.assigned[0]:
            ret =  'subl $1,%{0}\nadcl %{0},%{0}\nandl $1,%{0}'
            return ret.format(self.assigned[0])
        else:
            o = self.assigned[0]
            ret = 'movl %{1},%{0}\n' + \
                  'addl $-1,%{1}\n' + \
                  'sbbl %{1},%{0}\n'
            return ret.format(self.assigned[0],self.read[0])    
    ")
)





(instr X86Mov 
    (pattern ( (_) Move (_) ))
    (asmstr "mov %{1},%{0}")
    (extra "    
    def isMove(self):
        return True
    ")
)


(instr X86NeI32 
    (pattern (I32 Binop "!=" 
                (I32) (I32)))
    
    (asmstr 
       "cmp %{2},%{1}
        {instr.jmpinstr} {instr.branch}
        xor %{0},%{0}
        jmp {instr.exit}
        {instr.branch}:
        xor %{0},%{0}
        inc %{0}
        {instr.exit}:")
    
    (extra "    jmpinstr = 'jne'")
    
    (constructor "        
        self.branch = x86.newLocalLabel()
        self.exit = x86.newLocalLabel()
        ")
    
)

(instr X86LtI32 
    (pattern (I32 Binop "<" 
                (I32) (I32)))
    
    (asmstr 
       "cmp %{2},%{1}
        {instr.jmpinstr} {instr.branch}
        xor %{0},%{0}
        jmp {instr.exit}
        {instr.branch}:
        xor %{0},%{0}
        inc %{0}
        {instr.exit}:")
    
    (extra "    jmpinstr = 'jl'")
    
    (constructor "        
        self.branch = x86.newLocalLabel()
        self.exit = x86.newLocalLabel()
        ")
    
)

(instr X86GtI32 
    (pattern (I32 Binop ">" 
                (I32) (I32)))
    
    (asmstr 
       "cmp %{2},%{1}
        {instr.jmpinstr} {instr.branch}
        xor %{0},%{0}
        jmp {instr.exit}
        {instr.branch}:
        xor %{0},%{0}
        inc %{0}
        {instr.exit}:")
    
    (extra "    jmpinstr = 'jg'")
    
    (constructor "        
        self.branch = x86.newLocalLabel()
        self.exit = x86.newLocalLabel()
        ")
    
)



(instr X86EqI32 
    (pattern (I32 Binop "==" 
                (I32) (I32)))
    
    (asmstr 
       "cmp %{2},%{1}
        {instr.jmpinstr} {instr.branch}
        xor %{0},%{0}
        jmp {instr.exit}
        {instr.branch}:
        xor %{0},%{0}
        inc %{0}
        {instr.exit}:")
    
    (extra "    jmpinstr = 'je'")
    
    (constructor "        
        self.branch = x86.newLocalLabel()
        self.exit = x86.newLocalLabel()
        ")
    
)



(instr X86LoadConstantI32 
    (pattern ( (I32) LoadConstant ))
    (asmstr "mov ${instr.const},%{0}")
    (constructor "        
        self.const = node.instr.const    
    ")
)


(instr X86LoadLocalAddr
    (pattern ( (Pointer) LoadLocalAddr ))
    (asmstr 
    "    
        r = self.assigned[0]
        offset = self.sym.slot.offset
        if offset == None:
            offsetStr = 'XXX'
        else:
            offsetStr = str( (offset) ) 
        return 'mov %%ebp, %%%s\nsub $%s, %%%s'%(r,offsetStr,r)
    ")
    (constructor "        
        self.sym = node.instr.sym    
    ")
)

(instr X86LoadParamAddr
    (pattern ( (Pointer) LoadParamAddr ))
    (asmstr 
    "    
        r = self.assigned[0]
        offset = self.sym.slot.offset
        if offset == None:
            offsetStr = 'XXX'
        else:
            offsetStr = str( ( 8 + offset) ) 
        return 'mov %%ebp, %%%s\nadd $%s, %%%s'%(r,offsetStr,r)
    ")
    (constructor "        
        self.sym = node.instr.sym    
    ")
)

(instr X86LoadGlobalAddr
    (pattern ( (Pointer) LoadGlobalAddr ))
    (asmstr "leal {instr.sym.name}, %{0}")
    (constructor "        
        self.sym = node.instr.sym    
    ")
)




(instr X86StoreI32
    (pattern ( () Store (Pointer) (I32) ))
    (asmstr "movl %{1}, (%{0})")
)

(instr X86StorePointer
    (pattern ( () Store (Pointer) (Pointer) ))
    (asmstr "movl %{1}, (%{0})")
)


(instr X86DerefI32
    (pattern ( (I32) Deref (Pointer) ))
    (asmstr "mov (%{1}),%{0} ")
)

(instr X86DerefPointer
    (pattern ( (Pointer) Deref (Pointer) ))
    (asmstr "mov (%{1}),%{0} ")
)



(instr X86Branch
    (pattern (() Branch (I32) ))
    (asmstr "
        if self.successors[0] != None and self.successors[1] == None:
            return 'test %%%s,%%%s\njnz .%s'%(self.read[0],self.read[0],self.successors[0])
        elif self.successors[0] == None and self.successors[1] != None:
            return 'test %%%s,%%%s\njz .%s'%(self.read[0],self.read[0],self.successors[1])
        else:
            return 'test %%%s,%%%s\njnz .%s\njmp .%s'%(self.read[0],self.read[0],self.successors[0],self.successors[1])
        ")
    (constructor "        
        self.successors = node.instr.successors
        ")
)

(instr X86Jmp
    (pattern (() Jmp ))
    (asmstr "        
        if self.successors[0] == None:
            return ''
        else:
            return 'jmp .%s' % self.successors[0]
     ")
    (constructor "        
        self.successors = node.instr.successors
        ")
)




